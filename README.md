# ğŸ“š Algoritmos de OrdenaÃ§Ã£o â€” Projeto AcadÃªmico

Este repositÃ³rio contÃ©m implementaÃ§Ãµes de algoritmos clÃ¡ssicos de ordenaÃ§Ã£o, desenvolvidas com fins acadÃªmicos para a disciplina de Estruturas de Dados e Algoritmos.

O objetivo do projeto Ã© compreender o funcionamento, desempenho e aplicaÃ§Ãµes de diferentes mÃ©todos de ordenaÃ§Ã£o.

---

## ğŸ“Œ Algoritmos Implementados

Atualmente, o projeto conta com os seguintes algoritmos:

- Bubble Sort
- Insertion Sort
- Merge Sort
- Quick Sort
- Heap Sort

---

## ğŸ”¹ Bubble Sort

O **Bubble Sort** funciona comparando elementos adjacentes e trocando-os de posiÃ§Ã£o caso estejam fora de ordem.

O processo se repete atÃ© que nenhuma troca seja necessÃ¡ria, indicando que o vetor estÃ¡ ordenado.

### CaracterÃ­sticas:
- Complexidade: `O(nÂ²)`
- EstÃ¡vel: âœ…
- Simples implementaÃ§Ã£o
- Baixa performance em grandes volumes de dados

---

## ğŸ”¹ Insertion Sort

O **Insertion Sort** organiza os elementos inserindo-os na posiÃ§Ã£o correta dentro da parte jÃ¡ ordenada do vetor.

Funciona de forma semelhante Ã  organizaÃ§Ã£o de cartas na mÃ£o.

### CaracterÃ­sticas:
- Complexidade: `O(nÂ²)`
- EstÃ¡vel: âœ…
- Bom desempenho para listas pequenas
- Eficiente em vetores quase ordenados

---

## ğŸ”¹ Merge Sort

O **Merge Sort** utiliza a estratÃ©gia de **Dividir para Conquistar**.

O vetor Ã© dividido recursivamente em partes menores atÃ© conter apenas um elemento, e depois Ã© reorganizado de forma ordenada.

### CaracterÃ­sticas:
- Complexidade: `O(n log n)`
- EstÃ¡vel: âœ…
- Alto consumo de memÃ³ria
- Excelente para grandes conjuntos de dados

---

## ğŸ”¹ Quick Sort

O **Quick Sort** escolhe um elemento como pivÃ´ e reorganiza o vetor, colocando os menores Ã  esquerda e os maiores Ã  direita.

ApÃ³s isso, aplica o mesmo processo recursivamente nas partiÃ§Ãµes.

### CaracterÃ­sticas:
- Complexidade MÃ©dia: `O(n log n)`
- Pior caso: `O(nÂ²)`
- EstÃ¡vel: âŒ
- Muito rÃ¡pido na prÃ¡tica

---

## ğŸ”¹ Heap Sort

O **Heap Sort** utiliza uma estrutura chamada **Heap BinÃ¡rio** para ordenar os elementos.

Primeiro, o vetor Ã© transformado em um heap mÃ¡ximo. Em seguida, o maior elemento Ã© removido e colocado na posiÃ§Ã£o correta.

### CaracterÃ­sticas:
- Complexidade: `O(n log n)`
- EstÃ¡vel: âŒ
- NÃ£o utiliza memÃ³ria extra
- Performance consistente

---

## ğŸš€ Objetivos do Projeto

- Praticar conceitos de algoritmos de ordenaÃ§Ã£o
- Comparar desempenho entre mÃ©todos
- Desenvolver raciocÃ­nio lÃ³gico
- Aplicar teoria na prÃ¡tica
